id: explain
description: Build prompts that produce high-quality explanations
signature_template: input_context, objective, constraints -> compiled_prompt, checks
prompt_style: pedagogical_behavior_contract
compiler_principles: |
  You are an expert prompt engineer specializing in pedagogical tasks. Generate a single,
  production-quality system prompt that functions as a complete behavior contract for
  high-quality explanations.

  ## Generation Principles

  1. **Patient Teacher Role**: Open with a role that names the domain and the pedagogical
     stance (patient, knowledgeable teacher). Establish the target audience explicitly.
  2. **Constraint Fidelity**: Include ONLY constraints from the user's intent. Never invent
     prerequisite requirements, reading level rules, or format restrictions not in the request.
  3. **Knowledge Level is Sacred**: When the intent says "assume no knowledge", "explain from
     scratch", or similar — this is a HARD constraint. Every term must be explained using
     everyday language before being used. No domain jargon without prior definition.
  4. **Progressive Disclosure**: Build understanding layer by layer. Establish the simplest
     version first, then add complexity. Never require knowledge of a term before defining it.
  5. **Concrete Examples**: Require specific, tangible examples grounded in the learner's
     context. Abstract concepts must always be paired with real-world illustrations.
  6. **Measurable Criteria**: Replace "clear" or "simple" with verifiable standards
     (e.g., "explain without using the word X", "use an analogy from everyday life").
  7. **Comprehension Checks**: Embed lightweight self-check prompts after major concepts
     so the learner can verify understanding before moving on.
  8. **Adaptive Structure**: Use sections that fit the explanation — not a fixed template.
     Only include structure that genuinely aids comprehension for this specific topic.
  9. **Output Contract**: End with criteria for what a successful explanation looks like:
     what the learner should be able to do or say after reading it.

  ## Quality Standard

  Every instruction must serve the learner. Be specific about pedagogical strategy.
  Depth on what the user asked for — never impose a rigid format the intent did not request.
refine_principles: |
  You are refining an existing explanation prompt. Apply surgical, targeted improvements.

  ## Refinement Protocol

  1. **Diagnose First**: Identify the 2-3 highest-impact weaknesses from judge feedback.
  2. **Preserve What Works**: Keep sections that scored well.
  3. **Priority Order**: Knowledge-level violations → jargon without definition → clarity
     issues → missing examples. Fix knowledge-level issues first — they are the hardest
     to discover and the most damaging.
  4. **Strip Hallucinations**: Remove any rule, prerequisite, or format constraint NOT in
     the user's intent.
  5. **Add Missing Examples**: If the prompt lacks concrete examples for key concepts, add
     a requirement for them.
  6. **Verify Progressive Structure**: If the explanation order can confuse a novice, add
     explicit sequencing guidance.
  7. **Remove Structural Noise**: Strip envelope tags, bracket markup, and duplicate sections.
prompt_directives:
  - Open with a role definition as a patient, knowledgeable teacher
  - Define audience level explicitly and forbid hidden prerequisites
  - Use semantic XML tags to organize sections (e.g., <prerequisites>, <explanation_steps>, <examples>, <output_format>, <failure_policy>)
  - Explain concepts in progressive layers from fundamentals to details (progressive disclosure)
  - Include concrete examples inside <examples> tags and quick checks to confirm understanding after each major concept
  - Require step-by-step breakdowns for complex topics with explicit transitions between steps
  - Prefer plain, concrete language over abstract jargon — define every term before using it
  - End with a testable output contract specifying structure, depth, and what a good explanation looks like
  - Be dense and comprehensive — fill the token budget with actionable, specific guidance
  - Do NOT wrap the entire prompt in <system> or <prompt> envelope tags
quality_checklist:
  - objective and learner level are explicit
  - ALL constraints come from the user's intent — no hallucinated policies or rules
  - output format is NOT specified unless the user explicitly requested one
  - knowledge level from intent is deeply honored (if 'assume no knowledge', every term explained from basics)
  - each key term is defined before use in everyday language
  - explanation follows progressive disclosure — simple concepts first, complexity builds
  - examples are concrete, relevant, and grounded in the learner's context
  - output contract reflects the user's actual success criteria
  - role/identity is established in the opening lines
clarification_policy:
  - Ask for learner level or prior knowledge only when missing and relevant
  - Ask for domain context if it changes terminology or examples
ambiguity_resolution_rules:
  - Default to beginner-safe assumptions when level is unknown
  - Surface assumptions explicitly before giving advanced steps
forbidden_patterns:
  - etc
  - kind of
  - roughly
  - single-message only
  - exactly 3 rounds
  - arbitrary word limit
  - '[section]'
  - '[[block]]'
  - <system>
friction_markers:
  - in one message
  - single user message
  - maximum two rounds
  - at most two
  - up to three clarification rounds
  - allow up to three clarification attempts
  - interaction will end
  - after two clarification attempts
  - after three clarification attempts
  - "≤\u202f2,000 words"
  - 2,000 words per question
  - cited directly after the statement
  - in parentheses
  - "[instruction_hierarchy]"
  - "[input_boundary]"
  - "[failure_policy]"
  - "[output_contract]"
  - "[final_self_check]"
  - "[[instruction_hierarchy]]"
  - "[[input_boundary]]"
  - "[[failure_policy]]"
  - "[[output_contract]]"
  - "[[final_self_check]]"
  - "<prompt>"
  - "</system>"
required_sections:
  - goal
  - knowns
  - unknowns
  - explanation_method
  - examples
  - output_contract
required_prompt_blocks:
  - instruction_hierarchy
  - input_boundary
  - failure_policy
  - output_contract
  - final_self_check
required_technique_markers:
  - objective
  - constraints
  - explanation
  - examples
  - output contract
vague_markers:
  - etc
  - kind of
  - maybe
  - roughly
  - some
ambiguity_penalty_per_marker: 0.04
ambiguity_penalty_cap: 0.35
missing_sections_weight: 0.25
missing_techniques_weight: 0.20
eval_weights:
  quality: 0.4
  clarity: 0.35
  constraint_fit: 0.15
  brevity: 0.10
judge_rubric:
  priorities:
    - prioritize pedagogical sequence and prerequisite handling
    - penalize missing examples or unexplained jargon
  quality_checks:
    - explanation path is coherent and level-appropriate
    - includes concrete examples and expected outputs
  clarity_checks:
    - terms are defined before use
    - avoids abrupt jumps and overloaded instructions
  constraint_checks:
    - respects target audience assumptions and constraints
    - includes explicit output contract
  risk_checks:
    - flags unexplained advanced terminology
    - flags hidden prerequisites
